---
# Inspired by https://github.com/suiluj/pi-adhoc-mqtt-cluster/blob/master/install_scripts/vernemqinstall.txt.

- name: install build dependencies (round 1)
  apt:
    cache_valid_time: 86400
    name:
      - autoconf
      - git
      - libssl1.0-dev
      - libncurses5-dev
      - stow
  become: yes
  become_user: root


# libssh-dev won't install unless libssl1.0-dev is already present.
- name: install build dependencies (round 2)
  apt:
    cache_valid_time: 86400
    name:
      - libssh-dev
  become: yes
  become_user: root

# Store this to a register so we can use it on localhost.
- name: get host architecture
  shell: "echo '{{ ansible_architecture }}'"
  changed_when: False
  register: host_architecture

- name: ensure install directories exist
  file:
    state: directory
    path: "{{ item }}"
  with_items:
    - /opt/kerl
    - /opt/vernemq
  become: yes
  become_user: root

# erlang installer helper
- name: install kerl
  get_url:
    url: https://raw.githubusercontent.com/kerl/kerl/73b71512188fe6c16a01d1b983ee7d9508fe346a/kerl
    dest: /usr/local/bin/kerl
    mode: '0755'
  become: yes
  become_user: root

- name: check if pre-existing erlang build for architecture exists
  local_action: "stat path={{ playbook_dir }}/artifacts/kerl/{{ erlang_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
  register: stat_existing_erlang_build

- name: check for existing erlang installation
  stat:
    path: "/opt/kerl/{{ erlang_version }}"
  register: stat_erlang

- name: install pre-existing erlang build
  unarchive:
    src: "{{ playbook_dir }}/artifacts/kerl/{{ erlang_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    dest: /opt/kerl/
  when: stat_existing_erlang_build.stat.exists and not stat_erlang.stat.exists
  become: yes
  become_user: root

# This takes forever. It should generally only fire the first time
# this is being built for a particular version/architecture; after
# that it should be cached as a tarball locally.
- name: build and install erlang
  shell: >-
    kerl build {{ erlang_version }} &&
    kerl install {{ erlang_version }} /opt/kerl/{{ erlang_version }}
  when: not stat_erlang.stat.exists and not stat_existing_erlang_build.stat.exists
  become: yes
  become_user: root

- name: package erlang installation
  archive:
    path: "/opt/kerl/{{ erlang_version }}"
    dest: "/opt/kerl/{{ erlang_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
  when: not stat_existing_erlang_build.stat.exists
  become: yes
  become_user: root

# This might lead to issues if it's run on multiple hosts at once. It
# shouldn't ever get invoked after the initial build though, so just
# be careful to only let this run when there's only one host per
# architecture.
- name: store packaged erlang installation for future use
  fetch:
    src: "/opt/kerl/{{ erlang_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    dest: "{{ playbook_dir }}/artifacts/kerl/{{ erlang_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    flat: yes
  when: not stat_existing_erlang_build.stat.exists

- name: activate erlang build at boot
  copy:
    dest: /etc/profile.d/kerl.sh
    content: |
      source /opt/kerl/{{ erlang_version }}/activate
  become: yes
  become_user: root
  register: activate_erlang_at_boot

- name: check for existing vernemq installation
  stat:
    path: "/usr/local/stow/vernemq-{{ vernemq_version }}"
  register: stat_vernemq

- name: check if pre-existing vernemq build for architecture exists
  local_action: "stat path={{ playbook_dir }}/artifacts/vernemq/{{ vernemq_version}}.{{ host_architecture.stdout | trim }}.tar.gz"
  register: stat_existing_vernemq_build

- name: deploy pre-existing vernemeq build
  unarchive:
    src: "{{ playbook_dir }}/artifacts/vernemq/{{ vernemq_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    dest: /usr/local/stow/
  when: stat_existing_vernemq_build.stat.exists and not stat_vernemq.stat.exists
  become: yes
  become_user: root

- name: clone vernemq
  git:
    repo: https://github.com/vernemq/vernemq.git
    dest: "/usr/local/src/vernemq-{{ vernemq_version }}"
    version: "{{ vernemq_version }}"
    depth: 1
  when: not stat_vernemq.stat.exists and not stat_existing_vernemq_build.stat.exists
  become: yes
  become_user: root

- name: build vernemq and copy installation to stow directory
  shell: |
    cd /usr/local/src/vernemq-{{ vernemq_version }}
    make rpi32
    cp -r _build/rpi32/rel/vernemq /usr/local/stow/vernemq-{{ vernemq_version }}
  when: not stat_vernemq.stat.exists and not stat_existing_vernemq_build.stat.exists
  become: yes
  become_user: root
  # Needed to load erlang installation
  become_flags: -i

- name: check if vernemq installation has already been stowed
  stat:
    path: /usr/local/bin/vernemq
  register: stat_vernemq_stow

# Run this regardless of whether we already have the stowed binary, so
# we'll get an error if there's an unexpected version or something in
# /usr/local/bin/.
- name: stow vernemq installation
  shell: "stow vernemq-{{ vernemq_version }}"
  args:
    chdir: /usr/local/stow
  changed_when: not stat_vernemq_stow.stat.exists
  become: yes
  become_user: root

- name: package vernemq installation
  archive:
    path: "/usr/local/stow/vernemq-{{ vernemq_version }}"
    dest: "/opt/vernemq/{{ vernemq_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    exclude_path:
      - .git/
  when: not stat_existing_vernemq_build.stat.exists
  become: yes
  become_user: root

# See notes in comments for the equivalent erlang task above.
- name: store packaged vernemq installation for future use
  fetch:
    src: "/opt/vernemq/{{ vernemq_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    dest: "{{ playbook_dir }}/artifacts/vernemq/{{ vernemq_version }}.{{ host_architecture.stdout | trim }}.tar.gz"
    flat: yes
  when: not stat_existing_vernemq_build.stat.exists

- name: ensure the pi user can write to the vernemq configs
  file:
    path: "/usr/local/stow/vernemq-{{ vernemq_version }}/data"
    mode: '0644'
    owner: pi
    group: pi
    state: directory
  become: yes
  become_user: root

- name: set PAM limits for vernemq
  pam_limits:
    domain: '*'
    limit_item: nofile
    limit_type: "{{ item }}"
    value: '65536'
  with_items:
    - soft
    - hard
  become: yes
  become_user: root
  register: vernemq_pam

- name: reboot system to update PAM limits
  reboot:
  when: vernemq_pam.changed
  become: yes
  become_user: root

- name: add vernemq config
  copy:
    dest: "/usr/local/stow/vernemq-{{ vernemq_version }}/etc/vernemq.conf"
    src: "{{ role_path }}/files/vernemq.conf"
  become: yes
  become_user: root

- name: create vernemq systemd service
  copy:
    dest: /etc/systemd/system/vernemq.service
    content: |
      [Unit]
      Description=VerneMQ
      After=network.target

      [Service]
      ExecStart=/usr/local/bin/vernemq start
      ExecStop=/usr/local/bin/vernemq stop
      Environment=WAIT_FOR_ERLANG=240
      User=pi
      Type=forking
      Restart=always
      TimeoutSec=240
      RestartSec=30
      LimitNOFILE=65536

      [Install]
      WantedBy=multi-user.target
  become: yes
  become_user: root
  register: vernemq_systemd_service

- name: start vernemq now and on boot in the future
  shell: |
    systemctl daemon-reload
    systemctl enable vernemq.service
    systemctl start vernemq.service
  when: vernemq_systemd_service.changed
  become: yes
  become_user: root